// Code generated by protoc-gen-cli-client. DO NOT EDIT.

package event

import (
	cli_client "github.com/adlerhurst/cli-client"
	pflag "github.com/spf13/pflag"
	message "github.com/zitadel/zitadel/pkg/grpc/message"
	os "os"
)

type AggregateFlag struct {
	*Aggregate

	changed bool
	set     *pflag.FlagSet

	idFlag            *cli_client.StringParser
	typeFlag          *AggregateTypeFlag
	resourceOwnerFlag *cli_client.StringParser
}

func (x *AggregateFlag) AddFlags(parent *pflag.FlagSet) {
	x.set = pflag.NewFlagSet("Aggregate", pflag.ContinueOnError)

	x.idFlag = cli_client.NewStringParser(x.set, "id", "")
	x.resourceOwnerFlag = cli_client.NewStringParser(x.set, "resource-owner", "")
	x.typeFlag = &AggregateTypeFlag{AggregateType: new(AggregateType)}
	x.typeFlag.AddFlags(x.set)
	parent.AddFlagSet(x.set)
}

func (x *AggregateFlag) ParseFlags(parent *pflag.FlagSet, args []string) {
	flagIndexes := cli_client.FieldIndexes(args, "type")

	if err := x.set.Parse(flagIndexes.Primitives().Args); err != nil {
		cli_client.Logger().Error("failed to parse flags", "cause", err)
		os.Exit(1)
	}

	if flagIdx := flagIndexes.LastByName("type"); flagIdx != nil {
		x.typeFlag.ParseFlags(x.set, flagIdx.Args)
	}

	if x.idFlag.Changed() {
		x.changed = true
		x.Aggregate.Id = *x.idFlag.Value
	}

	if x.typeFlag.Changed() {
		x.changed = true
		x.Aggregate.Type = x.typeFlag.AggregateType
	}

	if x.resourceOwnerFlag.Changed() {
		x.changed = true
		x.Aggregate.ResourceOwner = *x.resourceOwnerFlag.Value
	}
}

func (x *AggregateFlag) Changed() bool {
	return x.changed
}

type AggregateTypeFlag struct {
	*AggregateType

	changed bool
	set     *pflag.FlagSet

	typeFlag      *cli_client.StringParser
	localizedFlag *message.LocalizedMessageFlag
}

func (x *AggregateTypeFlag) AddFlags(parent *pflag.FlagSet) {
	x.set = pflag.NewFlagSet("AggregateType", pflag.ContinueOnError)

	x.typeFlag = cli_client.NewStringParser(x.set, "type", "")
	x.localizedFlag = &message.LocalizedMessageFlag{LocalizedMessage: new(message.LocalizedMessage)}
	x.localizedFlag.AddFlags(x.set)
	parent.AddFlagSet(x.set)
}

func (x *AggregateTypeFlag) ParseFlags(parent *pflag.FlagSet, args []string) {
	flagIndexes := cli_client.FieldIndexes(args, "localized")

	if err := x.set.Parse(flagIndexes.Primitives().Args); err != nil {
		cli_client.Logger().Error("failed to parse flags", "cause", err)
		os.Exit(1)
	}

	if flagIdx := flagIndexes.LastByName("localized"); flagIdx != nil {
		x.localizedFlag.ParseFlags(x.set, flagIdx.Args)
	}

	if x.typeFlag.Changed() {
		x.changed = true
		x.AggregateType.Type = *x.typeFlag.Value
	}

	if x.localizedFlag.Changed() {
		x.changed = true
		x.AggregateType.Localized = x.localizedFlag.LocalizedMessage
	}

}

func (x *AggregateTypeFlag) Changed() bool {
	return x.changed
}

type EditorFlag struct {
	*Editor

	changed bool
	set     *pflag.FlagSet

	userIdFlag      *cli_client.StringParser
	displayNameFlag *cli_client.StringParser
	serviceFlag     *cli_client.StringParser
}

func (x *EditorFlag) AddFlags(parent *pflag.FlagSet) {
	x.set = pflag.NewFlagSet("Editor", pflag.ContinueOnError)

	x.userIdFlag = cli_client.NewStringParser(x.set, "user-id", "")
	x.displayNameFlag = cli_client.NewStringParser(x.set, "display-name", "")
	x.serviceFlag = cli_client.NewStringParser(x.set, "service", "")
	parent.AddFlagSet(x.set)
}

func (x *EditorFlag) ParseFlags(parent *pflag.FlagSet, args []string) {
	flagIndexes := cli_client.FieldIndexes(args)

	if err := x.set.Parse(flagIndexes.Primitives().Args); err != nil {
		cli_client.Logger().Error("failed to parse flags", "cause", err)
		os.Exit(1)
	}

	if x.userIdFlag.Changed() {
		x.changed = true
		x.Editor.UserId = *x.userIdFlag.Value
	}
	if x.displayNameFlag.Changed() {
		x.changed = true
		x.Editor.DisplayName = *x.displayNameFlag.Value
	}
	if x.serviceFlag.Changed() {
		x.changed = true
		x.Editor.Service = *x.serviceFlag.Value
	}
}

func (x *EditorFlag) Changed() bool {
	return x.changed
}

type EventFlag struct {
	*Event

	changed bool
	set     *pflag.FlagSet

	editorFlag       *EditorFlag
	aggregateFlag    *AggregateFlag
	sequenceFlag     *cli_client.Uint64Parser
	creationDateFlag *cli_client.TimestampParser
	payloadFlag      *cli_client.StructParser
	typeFlag         *EventTypeFlag
}

func (x *EventFlag) AddFlags(parent *pflag.FlagSet) {
	x.set = pflag.NewFlagSet("Event", pflag.ContinueOnError)

	x.sequenceFlag = cli_client.NewUint64Parser(x.set, "sequence", "")
	x.creationDateFlag = cli_client.NewTimestampParser(x.set, "creation-date", "")
	x.payloadFlag = cli_client.NewStructParser(x.set, "payload", "")
	x.editorFlag = &EditorFlag{Editor: new(Editor)}
	x.editorFlag.AddFlags(x.set)
	x.aggregateFlag = &AggregateFlag{Aggregate: new(Aggregate)}
	x.aggregateFlag.AddFlags(x.set)
	x.typeFlag = &EventTypeFlag{EventType: new(EventType)}
	x.typeFlag.AddFlags(x.set)
	parent.AddFlagSet(x.set)
}

func (x *EventFlag) ParseFlags(parent *pflag.FlagSet, args []string) {
	flagIndexes := cli_client.FieldIndexes(args, "editor", "aggregate", "type")

	if err := x.set.Parse(flagIndexes.Primitives().Args); err != nil {
		cli_client.Logger().Error("failed to parse flags", "cause", err)
		os.Exit(1)
	}

	if flagIdx := flagIndexes.LastByName("editor"); flagIdx != nil {
		x.editorFlag.ParseFlags(x.set, flagIdx.Args)
	}

	if flagIdx := flagIndexes.LastByName("aggregate"); flagIdx != nil {
		x.aggregateFlag.ParseFlags(x.set, flagIdx.Args)
	}

	if flagIdx := flagIndexes.LastByName("type"); flagIdx != nil {
		x.typeFlag.ParseFlags(x.set, flagIdx.Args)
	}

	if x.editorFlag.Changed() {
		x.changed = true
		x.Event.Editor = x.editorFlag.Editor
	}

	if x.aggregateFlag.Changed() {
		x.changed = true
		x.Event.Aggregate = x.aggregateFlag.Aggregate
	}

	if x.sequenceFlag.Changed() {
		x.changed = true
		x.Event.Sequence = *x.sequenceFlag.Value
	}
	if x.creationDateFlag.Changed() {
		x.changed = true
		x.Event.CreationDate = x.creationDateFlag.Value
	}
	if x.payloadFlag.Changed() {
		x.changed = true
		x.Event.Payload = x.payloadFlag.Value
	}

	if x.typeFlag.Changed() {
		x.changed = true
		x.Event.Type = x.typeFlag.EventType
	}

}

func (x *EventFlag) Changed() bool {
	return x.changed
}

type EventTypeFlag struct {
	*EventType

	changed bool
	set     *pflag.FlagSet

	typeFlag      *cli_client.StringParser
	localizedFlag *message.LocalizedMessageFlag
}

func (x *EventTypeFlag) AddFlags(parent *pflag.FlagSet) {
	x.set = pflag.NewFlagSet("EventType", pflag.ContinueOnError)

	x.typeFlag = cli_client.NewStringParser(x.set, "type", "")
	x.localizedFlag = &message.LocalizedMessageFlag{LocalizedMessage: new(message.LocalizedMessage)}
	x.localizedFlag.AddFlags(x.set)
	parent.AddFlagSet(x.set)
}

func (x *EventTypeFlag) ParseFlags(parent *pflag.FlagSet, args []string) {
	flagIndexes := cli_client.FieldIndexes(args, "localized")

	if err := x.set.Parse(flagIndexes.Primitives().Args); err != nil {
		cli_client.Logger().Error("failed to parse flags", "cause", err)
		os.Exit(1)
	}

	if flagIdx := flagIndexes.LastByName("localized"); flagIdx != nil {
		x.localizedFlag.ParseFlags(x.set, flagIdx.Args)
	}

	if x.typeFlag.Changed() {
		x.changed = true
		x.EventType.Type = *x.typeFlag.Value
	}

	if x.localizedFlag.Changed() {
		x.changed = true
		x.EventType.Localized = x.localizedFlag.LocalizedMessage
	}

}

func (x *EventTypeFlag) Changed() bool {
	return x.changed
}
