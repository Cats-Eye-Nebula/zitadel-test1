---
title: APIs V3 (Preview)
---

import DocCardList from '@theme/DocCardList';
import CodeBlock from '@theme/CodeBlock';
import ActionServiceProto from '!!raw-loader!./_v3_action_service.proto'
import ActionExecutionProto from '!!raw-loader!./_v3_action_execution.proto'
import ActionTargetProto from '!!raw-loader!./_v3_action_target.proto'
import ActionQueryProto from '!!raw-loader!./_v3_action_query.proto'
import LanguageProto from '!!raw-loader!./_v3_language_service.proto'

The APIs described in this section are currently either in *Preview* stage or not implemented, yet.
Before using these APIs, pleases consider the [API release policy below](#api-release-policy)

## We Appreciate your Help

We invite you to...
- ... share your thoughts about the concepts by opening discussions on GitHub.
- ... try the implementations and provide feedback by filing issues on GitHub.

## The Problems

The current ZITADEL *GA* APIs are structured around contexts like System, Admin, Management, and Auth.
This structure leads to duplicate methods and makes it hard to find the right API for the right task.
Especially interacting with resources from multiple organizations is cumbersome.
Also, the APIs evolved over time, which lead to inconsistencies and a lack of flexibility in development.

## The Improvements

### Service Structure

Instead of structuring the API methods around contexts, new APIs are structured around resources and settings.
This means, eventually, we deprecate the old System-, Admin-, Management- and AuthAPIs in favor of User-, Action-, Language-, FeatureAPIs and so on.
This change makes it easier to find the right API for the right task, especially for multi-organization resources.
Also, it allows for faster development and independent versioning of the APIs.

### Multitenancy Management and Consistency

To improve managing and reusing resources and settings in multitenancy scenarios, we define some rules for the new APIs:

- Single properties from instance settings are overridable (patchable) in organizations.
- Some settings support user-defined custom properties that are also overridable in organizations.
- Improved experience with reusing resources in multiple organizations and instances.
- Resources are searchable over all organizations with a single call by default.

### HTTP and gRPC Consistency

To make the APIs more consistent and easier to use, we follow the same patterns in all Proto files.
- Patching is favored over updating resources and settings.
- HTTP calls are mapped so that query parameters can be used as much as possible. We avoid the annotation `body: "*"`.
- For search performance, we enforce query limits.

## Standard Resources

Standard resources exist in exactly one context.
For example, a user is always assigned to exactly one organization.
Or one SMS provider is always assigned to exactly one instance.

### Standard Resources Behavior

- Search request results can be scoped to a RequestContext.
- Search request results only contain results for which the requesting user has the necessary read permissions.
- Search requests are limited to 100 by default. The limit can be increased by the caller up to 1000 by default.
- Resource configurations are partially updatable. With HTTP, this is done via PATCH requests. If no changes were made, the response is successful.
- Status changes or other actions on resources with side effects are done via POST requests. Their HTTP path ends with the underscore prefixed action name. For example `POST /resources/idps/{id}/_activate`.

### Standard Resources Proto Example

<details><summary>session_service.proto</summary>
    <CodeBlock language="protobuf">{SessionProto}</CodeBlock>
</details>

## Reusable Resources

Reusable resources are like standard resources but can be reused in multiple contexts.
For example, an external identity provider can be defined once on the instance.
Each organization within this instance can then choose to use this identity provider or not.

### Reusable Resources Behavior

Reusable resources have the same behavior as standard resources with the following additions:

- Reusable resources can be created in a given context level (system, instance, org).
- For requests, that require a resource ID, no request context is needed.
- Reusable resources are available in child contexts and by default have the same state (active or inactive) as in their immediate parent context.
- In child contexts, the state of a reused resource is *inherited* by default and can be changed to *active*, *inactive* or *inherit*.
- In child contexts, a reused resources configuration is read-only.
- Child contexts can always read the following properties of reused resources:
    - ID
    - name
    - description
    - state
    - sequence
    - last changed date
    - parent context
    - effective state in the immediate parent context.
- Managers of reusable resources in a parent context can restrict their readability in child contexts to the properties listed above.

Typically, a new resource is first designed and implemented as a non-reusable resource.
If the community sees a benefit in reusing the resource in multiple contexts, reusability is added to the resource.

### Reusable Resources Proto Example

<details><summary>user_schema_service.proto</summary>
    <CodeBlock language="protobuf">{UserSchemaProto}</CodeBlock>
</details>

## Resource Services

All resource services support the following CRUD operations [as described above](#Standard Resources Behavior).

- Create
- Read (list, get)
- Update (partially, success on no changes)
- Delete


### zitadel.resources.action.v3alpha.ZITADELActions

- standard CRUD methods for Executions
- standard CRUD methods for Targets

Additional to the standard CRUD methods:

- ListAvailableExecutionServices
- ListAvailableExecutionMethods
- ListAvailableExecutionFunctions

<details><summary>action_service.proto</summary>
    <CodeBlock language="protobuf">{ActionServiceProto}</CodeBlock>
</details>

<details><summary>action_target.proto</summary>
    <CodeBlock language="protobuf">{ActionTargetProto}</CodeBlock>
</details>

<details><summary>action_execution.proto</summary>
    <CodeBlock language="protobuf">{ActionExecutionProto}</CodeBlock>
</details>

<details><summary>action_query.proto</summary>
    <CodeBlock language="protobuf">{ActionQueryProto}</CodeBlock>
</details>

### zitadel.resources.user.v3alpha.ZITADELUsers

standard CRUD methods

### zitadel.resources.userschema.v3alpha.ZITADELUserSchemas

standard CRUD methods

### zitadel.resources.instance.v3alpha.ZITADELInstances

additional to the standard CRUD methods:

- Limit (partial update of block and audit log retention)
- BulkLimit (partial update of block and audit log retention for multiple instances)

### zitadel.resources.organization.v3alpha.ZITADELOrganizations

additional to the standard CRUD methods:

- IsUnique
- GetOIDCInformation
- SetAsInstanceDefault
- GetInstanceDefault

### zitadel.resources.domain.v3alpha.ZITADELDomains

additional to the standard CRUD methods:

- SetAsPrimary
- Validate
- Exists

### zitadel.resources.secretgenerator.v3alpha.ZITADELSecretGenerators

standard CRUD methods

### zitadel.resources.project.v3alpha.ZITADELProjects

standard CRUD methods

### zitadel.resources.app.v3alpha.ZITADELApps

standard CRUD methods

### zitadel.resources.session.v3alpha.ZITADELSessions

standard CRUD methods

### zitadel.resources.membership.v3alpha.ZITADELMemberships

The given context defines the organization, instance or system where the membership is created.
The context and the user ID together are unique.

additional to the standard CRUD methods:

- ListAvailableRoles (context-aware)

### zitadel.resources.grant.v3alpha.ZITADELGrants

- standard CRUD methods for project grants
- standard CRUD methods for user grants
- standard CRUD methods for roles

### zitadel.resources.idp.v3alpha.ZITADELIdentityProviders (reusable)

standard CRUD and methods for all IDPs and standard methods for reusable resources

### zitadel.resources.smtp.v3alpha.ZITADELSMTPProviders

standard CRUD methods

### zitadel.resources.sms.v3alpha.ZITADELSMSProviders

standard CRUD methods

## Settings

Settings have no identity (ID) and are always context-aware.
They also don't have a state like active or inactive.
They only have properties that can be set and queried.
These properties are inherited to from parent-contexts (instance) to child-contexts (organization).

### Behavior

- Setting and retrieving settings is always context-aware. By default, the context is the instance discovered by the requests *Host* header.
- All settings properties can be partially overridden in child-contexts.
- All settings properties can be partially reset in child-contexts, so their values default to the parent contexts property values.
- All settings properties returned by queries contain the value and if it is inherited, the context where it is inherited from.

### Proto Example

<details><summary>language_service.proto</summary>
    <CodeBlock language="protobuf">{LanguageProto}</CodeBlock>
</details>

## Settings Services

### zitadel.settings.text.v3alpha.ZITADELTexts

key-value pairs for localized login texts, previously known as login texts

### zitadel.settings.branding.v3alpha.ZITADELBranding

predefined branding settings and custom key-value pairs, previously known as label policy or branding settings

### zitadel.settings.login.v3alpha.ZITADELLogin

previously known as login policy

### zitadel.settings.lockout.v3alpha.ZITADELLockout

previously known as lockout policy

### zitadel.settings.password.v3alpha.ZITADELPassword

previously known as password complexity policy

### zitadel.settings.help.v3alpha.ZITADELHelp

previously known as legal and support settings or privacy policy

### zitadel.settings.domain.v3alpha.ZITADELDomain

previously known as domain policy

### zitadel.settings.feature.v3alpha.ZITADELFeatures

feature toggles

also contains disallow public org registrations on system and instance level.

### zitadel.settings.language.v3alpha.ZITADELLanguages

default language, restricted languages, supported languages

### zitadel.settings.template.v3alpha.ZITADELTemplates

html and text templates for fully customizable emails and sms

## Insights Services

query services for auditing, analytics and data synchronization.

### zitadel.insights.event.v3alpha.ZITADELEvents

The given queries are checked against the requesting users permissions.

### zitadel.insights.milestone.v3alpha.ZITADELMilestones

The given queries are checked against the requesting users permissions.

## zitadel.operations.v3alpha.ZITADELOperations

- Health
- Failed Events
- Views
- Metrics (version, uptime etc.)
- Import/Export

## API Release Policy

- Defined but not yet implemented APIs are subject to change without further notice.
- Once an API definition is implemented, it is released as *Preview* and is available for testing.
- When a *Preview* API is tested enough so the concepts are proven to work, a new *Beta* API is released.
- When an API is feature-complete and stable enough, a new *GA* (General Availability) API is released.
- In all stages, changes to already implemented APIs are done in a backwards-compatible way, if possible.
- When we release a new stage for an API, we deprecate the previous stage and keep it available for a smooth transition.

## Preview APIs

These APIs are ready for testing and feedback.
Beware, they don't yet follow all the rules defined above.

<DocCardList />