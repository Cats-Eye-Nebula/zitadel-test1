---
title: APIs Preview
---

import DocCardList from '@theme/DocCardList';
import CodeBlock from '@theme/CodeBlock';
import SessionProto from '!!raw-loader!./_preview_session_service.proto'
import UserSchemaProto from '!!raw-loader!./_preview_user_schema_service.proto'
import LanguageProto from '!!raw-loader!./_preview_language_service.proto'

The APIs described in this section are currently either in *Preview* stage or not implemented, yet.
Before using these APIs, pleases consider the [API release policy below](#api-release-policy)

## We Appreciate your Help

We invite you to...
- ... share your thoughts about the concepts by opening discussions on GitHub.
- ... try the implementations and provide feedback by filing issues on GitHub.

## TL;DR

### The Problems

The current ZITADEL *GA* APIs are structured around contexts like System, Admin, Management, and Auth.
This structure leads to duplicate methods and makes it hard to find the right API for the right task.
Especially interacting with resources from multiple organizations is cumbersome.
Also, the APIs evolved over time, which lead to inconsistencies and a lack of flexibility in development.

### The Improvements

#### Service Structure

Instead of structuring the API methods around contexts, new APIs are structured around resources and settings.
This means, eventually, we deprecate the old System-, Admin-, Management- and AuthAPIs in favor of User-, Action-, Language-, FeatureAPIs and so on.
This change makes it easier to find the right API for the right task, especially for multi-organization resources.
Also, it allows for faster development and independent versioning of the APIs.

#### Multitenancy Management and Consistency

To improve managing and reusing resources and settings in multitenancy scenarios, we define some rules for the new APIs:

- Single properties from instance settings are overridable (patchable) in organizations.
- Some settings support user-defined custom properties that are also overridable in organizations.
- Improved experience with reusing resources in multiple organizations and instances.
- Resources are searchable over all organizations with a single call by default.

#### HTTP and gRPC Consistency

To make the APIs more consistent and easier to use, we follow the same patterns in all Proto files.
- Patching is favored over updating resources and settings.
- HTTP calls are mapped so that query parameters can be used as much as possible. We avoid the annotation `body: "*"`.
- For search performance, we enforce query limits.

## Standard Resources

Standard resources exist in exactly one context.
For example, a user is always assigned to exactly one organization.
Or one SMS provider is always assigned to exactly one instance.

### Behavior

- Search request results can be scoped to a RequestContext.
- Search request results only contain results for which the requesting user has the necessary read permissions.
- Search requests are limited to 100 by default. The limit can be increased up to 1000.
- Resource configurations are partially updatable. With HTTP, this is done via PATCH requests. If no changes were made, the response is successful.
- Status changes or other actions on resources with side effects are done via POST requests. Their HTTP path ends with the underscore prefixed action name. For example `POST /resources/idps/{id}/_activate`.

### Proto Example

<details><summary>session_service.proto</summary>
    <CodeBlock language="protobuf">{SessionProto}</CodeBlock>
</details>

## Reusable Resources

Reusable resources are like standard resources but can be reused in multiple contexts.
For example, an external identity provider can be defined once on the instance.
Each organization within this instance can then choose to use this identity provider or not.

### Behavior

Reusable resources have the same behavior as standard resources with the following additions:

- Reusable resources can be created in a given context level (system, instance, org).
- For requests, that require a request ID, no request context is needed.
- Reusable resources are available in child contexts and by default have the same state (active or inactive) as in their immediate parent context.
- In child contexts, the state of a reused resource is *inherited* by default and can be changed to *active*, *inactive* or *inherit*.
- In child contexts, a reused resources configuration is read-only.
- Child contexts can always read the following properties of reused resources:
    - ID
    - name
    - description
    - state
    - sequence
    - last changed date
    - parent context
    - effective state in the immediate parent context.
- Managers of reusable resources in a parent context can restrict their readability in child contexts to the properties listed above.

Typically, a new resource is first designed and implemented as a non-reusable resource.
If the community sees a benefit in reusing the resource in multiple contexts, reusability is added to the resource.

### Proto Example

<details><summary>user_schema_service.proto</summary>
    <CodeBlock language="protobuf">{UserSchemaProto}</CodeBlock>
</details>

## Resource Services

### Tenants

- Instances
- InstanceDomains
- Organizations
- Organization Domains

### Projects

- Projects
- Apps
- Roles

### Users

- Users
- UserSchemas (reusable)

### Sessions

- Sessions

### Authorizations

- Memberships
- Grants

### Actions (reusable)

- Executions
- Targets

### Identity Providers (reusable)

- Identity Providers

### Notifiers (reusable)

only target types system and instance

- SMTPProviders
- SMSProviders

## Settings

Settings have no identity (ID) and are always context-aware.
They also don't have a state like active or inactive.
They only have properties that can be set and queried.
These properties are inherited to from parent-contexts (instance) to child-contexts (organization).

### Behavior

- Setting and retrieving settings is always context-aware. By default, the context is the instance discovered by the requests *Host* header.
- All settings properties can be partially overridden in child-contexts.
- All settings properties can be partially reset in child-contexts, so their values default to the parent contexts property values.
- All settings properties returned by queries contain the value and if it is inherited, the context where it is inherited from.

### Proto Example

<details><summary>language_service.proto</summary>
    <CodeBlock language="protobuf">{LanguageProto}</CodeBlock>
</details>

## Settings Services

### Texts

Key-value pairs for localized login texts, previously known as login texts

### Branding

Predefined branding settings and custom key-value pairs, previously known as label policy or branding settings

### Login

previously known as login policy

### Lockout

previously known as lockout policy

### Password

previously known as password complexity policy

### Help

previously known as legal and support settings or privacy policy

### Domain

previously known as domain policy

### Features

feature toggles

### Languages

default language, restricted languages

### Instances

instance-wide settings like disallow_public_org_registration. These settings are not overwritable for orgs

### Templates

html and text templates for fully customizable emails and sms

### Limits (really?)

only on instance level with system-level permissions

## Insight Services

- Events
- Failed Events
- Milestones

## Operations Services

- Health
- Limits
- Views
- Runtime (version, build, etc.)

## API Release Policy

- Defined but not yet implemented APIs are subject to change without further notice.
- Once an API definition is implemented, it is released as *Preview* and is available for testing.
- When a *Preview* API is tested enough so the concepts are proven to work, a new *Beta* API is released.
- When an API is feature-complete and stable enough, a new *GA* (General Availability) API is released.
- In all stages, changes to already implemented APIs are done in a backwards-compatible way, if possible.
- When we release a new stage for an API, we deprecate the previous stage and keep it available for a smooth transition.

## Preview APIs

These APIs are ready for testing and feedback.
Beware, they don't yet follow all the rules defined above.

<DocCardList />