---
title: APIs V3 (Preview)
---

import DocCardList from '@theme/DocCardList';
import CodeBlock from '@theme/CodeBlock';
import ActionServiceProto from '!!raw-loader!./_v3_action_service.proto'
import ActionExecutionProto from '!!raw-loader!./_v3_action_execution.proto'
import ActionTargetProto from '!!raw-loader!./_v3_action_target.proto'
import ActionQueryProto from '!!raw-loader!./_v3_action_query.proto'
import LanguageServiceProto from '!!raw-loader!./_v3_language_service.proto'
import LanguageProto from '!!raw-loader!./_v3_language.proto'

The APIs described in this section are currently either in *Preview* stage or not implemented, yet.
Before using these APIs, pleases consider the [API release policy below](#api-release-policy)

## We Appreciate your Help

We invite you to...
- ... share your thoughts about the concepts by opening discussions on GitHub.
- ... try the implementations and provide feedback by filing issues on GitHub.

## The Problems

The current ZITADEL *GA* APIs are structured around contexts like System, Admin, Management, and Auth.
This structure leads to duplicate methods and makes it hard to find the right API for the right task.
Especially interacting with resources from multiple organizations is cumbersome.
Also, the APIs evolved over time, which lead to inconsistencies and a lack of flexibility in development.

## The Improvements

### Service Structure

Instead of structuring the API methods around contexts, new APIs are structured around resources and settings.
This means, eventually, we deprecate the old System-, Admin-, Management- and AuthAPIs in favor of User-, Action-, Language-, FeatureAPIs and so on.
This change makes it easier to find the right API for the right task, especially for multi-organization resources.
Also, it allows for faster development and independent versioning of the APIs.

### Multitenancy Management and Consistency

To improve managing and reusing resources and settings in multitenancy scenarios, we define some rules for the new APIs:

- Single properties from instance settings are overridable (patchable) in organizations.
- Some settings support user-defined custom properties that are also overridable in organizations.
- Improved experience with reusing resources in multiple organizations and instances.
- Resources are searchable over all organizations with a single call by default.

### HTTP and gRPC Consistency

To make the APIs more consistent and easier to use, we follow the same patterns in all Proto files.
- Patching is favored over updating resources and settings.
- HTTP calls are mapped so that query parameters can be used as much as possible. We avoid the annotation `body: "*"`.
- For search performance, we enforce query limits.

## Standard Resources

Standard resources exist in exactly one context.
For example, a user is always assigned to exactly one organization.
Or one SMS provider is always assigned to exactly one instance.

Standard resource methods behave like this:

- Search request results can be scoped to a RequestContext.
- Search request results only contain results for which the requesting user has the necessary read permissions.
- Search requests are limited to 100 by default. The limit can be increased by the caller up to 1000 by default.
- Resource configurations are partially updatable. With HTTP, this is done via PATCH requests. If no changes were made, the response is successful.
- Status changes or other actions on resources with side effects are done via POST requests. Their HTTP path ends with the underscore prefixed action name. For example `POST /resources/idps/{id}/_activate`.

For a concrete proto example, have a look at the [ZITADELActions service](#zitadelactions).

## Reusable Resources

Reusable resources are like standard resources but can be reused in multiple contexts.
For example, an external identity provider can be defined once on the instance.
Each organization within this instance can then choose to use this identity provider or not.

Additionally to the methods described for standard resources, reusable have the following capabilities:

Reusable resources have the same behavior as standard resources with the following additions:

- Reusable resources can be created in a given context level (system, instance, org).
- For requests, that require a resource ID, no request context is needed.
- Reusable resources are available in child contexts and by default have the same state (active or inactive) as in their immediate parent context.
- In child contexts, the state of a reused resource is *inherited* by default and can be changed to *active*, *inactive* or *inherit*.
- In child contexts, a reused resources configuration is read-only.
- Child contexts can always read the following properties of reused resources:
    - ID
    - name
    - description
    - state
    - sequence
    - last changed date
    - parent context
    - effective state in the immediate parent context.
- Managers of reusable resources in a parent context can restrict their readability in child contexts to the properties listed above.

Typically, a new resource is first designed and implemented as a non-reusable resource.
If the community sees a benefit in reusing the resource in multiple contexts, reusability is added to the resource.

For a concrete proto example, have a look at the [ZITADELIdentityProviders service](#zitadelidentityproviders).

## Resource Services

All resource services support the following CRUD operations [as described above](#standard-resources-behavior).

- Create
- Read (get, search)
- Patch (partially update, success on no changes)
- Delete

### ZITADELActions

- standard CRUD methods for Executions
- standard CRUD methods for Targets

Additional to the standard CRUD methods:

- ListAvailableExecutionServices
- ListAvailableExecutionMethods
- ListAvailableExecutionFunctions

<details><summary>action_service.proto</summary>
    <CodeBlock language="protobuf">{ActionServiceProto}</CodeBlock>
</details>

<details><summary>action_target.proto</summary>
    <CodeBlock language="protobuf">{ActionTargetProto}</CodeBlock>
</details>

<details><summary>action_execution.proto</summary>
    <CodeBlock language="protobuf">{ActionExecutionProto}</CodeBlock>
</details>

<details><summary>action_query.proto</summary>
    <CodeBlock language="protobuf">{ActionQueryProto}</CodeBlock>
</details>

### ZITADELUsers

standard CRUD methods

### ZITADELUserSchemas

standard CRUD methods

### ZITADELInstances

additional to the standard CRUD methods:

- Limit (partial update of block and audit log retention)
- BulkLimit (partial update of block and audit log retention for multiple instances)

### ZITADELOrganizations

additional to the standard CRUD methods:

- SetAsInstanceDefault
- GetInstanceDefault

### ZITADELDomains

additional to the standard CRUD methods:

- SetAsPrimary
- Validate

### ZITADELProjects

standard CRUD methods

### ZITADELApps

standard CRUD methods

### ZITADELSessions

standard CRUD methods

### ZITADELMemberships

The given context defines the organization, instance or system where the membership is created.
The context and the user ID together are unique.

additional to the standard CRUD methods:

- ListAvailableRoles (context-aware)

### ZITADELGrants

- standard CRUD methods for project grants
- standard CRUD methods for user grants
- standard CRUD methods for roles

### ZITADELIdentityProviders (reusable)

standard CRUD and methods for all IDPs and standard methods for reusable resources

### ZITADELSMTPProviders

standard CRUD methods

### ZITADELSMSProviders

standard CRUD methods

## Settings

Settings have no identity (ID) and are always context-aware.
They also don't have a state like active or inactive.
They only have properties that can be set and queried.
These properties are inherited to from parent-contexts (instance) to child-contexts (organization).

Settings behave like this:

- Setting and retrieving settings is always context-aware. By default, the context is the instance discovered by the requests *Host* header.
- All settings properties can be partially overridden in child-contexts.
- All settings properties can be partially reset in child-contexts, so their values default to the parent contexts property values.
- All settings properties returned by queries contain the value and if it is inherited, the context where it is inherited from.

For a concrete proto example, have a look at the [ZITADELLanguageSettings service](#zitadellanguagesettings).

## Settings Services

### ZITADELLanguageSettings

default language, restricted languages, supported languages

<details><summary>language_service.proto</summary>
    <CodeBlock language="protobuf">{LanguageServiceProto}</CodeBlock>
</details>

<details><summary>language.proto</summary>
    <CodeBlock language="protobuf">{LanguageProto}</CodeBlock>
</details>

### ZITADELTextSettings

key-value pairs for localized login texts, previously known as login texts

### ZITADELBrandingSettings

predefined branding settings and custom key-value pairs, previously known as label policy or branding settings

### ZITADELLoginSettings

previously known as login policy

### ZITADELLockoutSettings

previously known as lockout policy

### ZITADELPasswordSettings

previously known as password complexity policy

### ZITADELHelpSettings

previously known as legal and support settings or privacy policy

### ZITADELDomainSettings

previously known as domain policy

### ZITADELFeatureSettings

feature toggles

also contains disallow public org registrations on system and instance level.

### ZITADELTemplatesSettings

html and text templates for fully customizable emails and sms

### ZITADELSecretSettings

replaces secret generators

## API Release Policy

- Defined but not yet implemented APIs are subject to change without further notice.
- Once an API definition is implemented, it is released as *Preview* and is available for testing.
- When a *Preview* API is tested enough so the concepts are proven to work, a new *Beta* API is released.
- When an API is feature-complete and stable enough, a new *GA* (General Availability) API is released.
- In all stages, changes to already implemented APIs are done in a backwards-compatible way, if possible.
- When we release a new stage for an API, we deprecate the previous stage and keep it available for a smooth transition.

## Preview APIs

These APIs are ready for testing and feedback.
Beware, they don't yet follow all the rules defined above.

<DocCardList />